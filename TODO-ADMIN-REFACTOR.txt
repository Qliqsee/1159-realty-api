ADMIN MODULE OPTIMIZATION - EFFICIENCY AND CONSISTENCY IMPROVEMENTS

CONTEXT AND GOALS:
The admin module needs to be aligned with the client module refactoring for consistency. Currently, admin endpoints have inconsistent response structures (some include capabilities, others don't), and bank account management is scattered across multiple endpoints. The goal is to standardize admin responses with optional query parameters for performance, integrate bank account data into the main admin DTO, and ensure admin's client-related endpoints use the refactored client DTOs.

PREREQUISITES:
This refactoring MUST be done AFTER the client module refactoring in TODO.txt is complete, as admin controller has client endpoints that depend on the new ClientResponseDto structure.

KEY PRINCIPLES:
1. Single unified AdminResponseDto for all endpoints with optional fields via query parameters
2. Capabilities empty unless explicitly requested via query param OR user requesting their own profile (/admins/me always includes capabilities)
3. Roles always included in all responses (never optional, required for permissions)
4. Bank account data integrated into main AdminResponseDto (no separate endpoints needed)
5. Users can only update their own bank account, admins cannot update other admin's bank accounts
6. Use query parameters to selectively include capabilities to avoid unnecessary capability service calls
7. Admin's client endpoints follow the same query param pattern as client module

DATA STORAGE STRATEGY:
Admin Table: Bank account data (accountNumber, bankCode, accountName, bankName) remains on Admin table since admins do not have a KYC system. This data is needed for commission disbursements.
Unlike clients, there is no data duplication issue since admins have no KYC JSON to sync with.
All personal info (firstName, lastName, phone, address fields) stored directly on Admin table.

PHASE 1: DTO RESTRUCTURING
Update src/admins/dto/admin-response.dto.ts to modify AdminResponseDto structure.
Add bank account fields to base AdminResponseDto: accountNumber (optional string), bankCode (optional string), accountName (optional string), bankName (optional string). Use ApiPropertyOptional decorators.
Keep existing base fields: id, userId, email, isEmailVerified, firstName, lastName, otherName, phone, dateOfBirth, street, city, state, country, postalCode, canOnboardClients, isBanned, isSuspended, roles (always included), createdAt, updatedAt.
Add optional capabilities field to AdminResponseDto with ApiPropertyOptional decorator (capabilities: string array).
Remove AdminProfileResponseDto class entirely since we now have unified response with optional capabilities.
Keep AdminListResponseDto as is with data array of AdminResponseDto and meta PaginationMetaDto.
Remove BankAccountResponseDto class entirely since bank data is now in main DTO (no masking needed, users only see their own).

PHASE 2: CREATE QUERY PARAM DTO
Create src/admins/dto/admin-include-query.dto.ts for query parameters.
Define AdminIncludeQueryDto class with optional boolean field: includeCapabilities.
Use IsBoolean and IsOptional decorators with Transform decorator to handle string to boolean conversion (query params are strings).
Add ApiPropertyOptional decorator for Swagger documentation with example showing ?includeCapabilities=true.
Note: Roles are ALWAYS included and not optional, so no includeRoles parameter needed.

PHASE 3: UPDATE ADMIN SERVICE
Refactor findByUserId method in src/admins/admins.service.ts to accept optional query params object.
For GET /admins/me always fetch capabilities regardless of query param (special case for authenticated user requesting own profile).
Method should always include user.userRoles.role join since roles are mandatory in response.
When capabilities requested or endpoint is /me, call capabilitiesService.getUserCapabilities.
Refactor findOne method to accept optional query params object and conditionally fetch capabilities based on params.
Default behavior when no query params: return base admin fields with roles but no capabilities (saves capability service call).
Refactor findAll method to accept optional query params object for capabilities.
When includeCapabilities is true in list endpoint, fetch capabilities for each admin in the list (may be expensive, document this in Swagger).
Remove mapToAdminProfileResponse method since we now have unified response structure.
Update mapToAdminResponse to accept optional capabilities array parameter and conditionally include it.
When mapping, include bank account fields from admin table: accountNumber, bankCode, accountName, bankName.
Bank account fields are not masked - users see full data since they can only access their own via /me endpoint.
Keep mapToAdminSummary method as is for summary representations used in other DTOs.

PHASE 4: UPDATE ADMIN CONTROLLER
Import AdminIncludeQueryDto in src/admins/admins.controller.ts.
Update GET /admins/me endpoint to accept @Query() query: AdminIncludeQueryDto parameter but always include capabilities regardless of query param.
Pass query params to adminsService.findByUserId but document that capabilities are always returned for /me.
Update ApiResponse decorator to use AdminResponseDto instead of AdminProfileResponseDto.
Update PATCH /admins/me endpoint to return AdminResponseDto with capabilities always included.
Update GET /admins/:id endpoint to accept @Query() query: AdminIncludeQueryDto parameter.
Pass query params to adminsService.findOne method.
Update ApiResponse decorator to use AdminResponseDto.
Add ApiQuery decorator for includeCapabilities parameter to document it in Swagger.
Update GET /admins (list) endpoint to accept @Query() query that extends both AdminQueryDto and AdminIncludeQueryDto.
Pass query params to adminsService.findAll method.
Add ApiQuery decorator for includeCapabilities parameter with warning that this may impact performance on large lists.
Remove PATCH /admins/:id/bank-account endpoint entirely (users update via PATCH /admins/me).
Remove GET /admins/:id/bank-account endpoint entirely (users get via GET /admins/me).
Remove DELETE /admins/:id/bank-account endpoint entirely (users delete via PATCH /admins/me with null values).

PHASE 5: UPDATE ADMIN DTO FOR BANK FIELDS
Update src/admins/dto/update-admin.dto.ts to ensure bank fields are included.
Verify UpdateAdminDto has optional fields: accountNumber (string), bankCode (string), accountName (string), bankName (string).
These fields should already exist based on previous work, just verify they are present.
Users can update their own bank account via PATCH /admins/me with these fields in the payload.
Remove src/admins/dto/bank-account.dto.ts file entirely since we no longer need UpdateBankAccountDto or BankAccountResponseDto.

PHASE 6: UPDATE ADMIN SERVICE BANK METHODS
Remove updateBankAccount method entirely from src/admins/admins.service.ts.
Remove getBankAccount method entirely from src/admins/admins.service.ts.
Remove deleteBankAccount method entirely from src/admins/admins.service.ts.
Remove maskBankAccount private method entirely since we no longer mask bank data (users only see their own).
Bank account updates are now handled through the existing updateProfile method which accepts UpdateAdminDto.
To delete bank account, users pass null values for accountNumber, bankCode, accountName, bankName in PATCH /admins/me.

PHASE 7: UPDATE ADMIN CLIENT ENDPOINTS
IMPORTANT: This phase depends on client module refactoring being completed first (TODO.txt).
Update GET /admins/my-clients endpoint in src/admins/admins.controller.ts to ensure it works with new ClientResponseDto structure.
Verify getMyClients method in adminsService returns ClientListResponseDto with new ClientResponseDto structure.
Update mapToClientSummary if needed but likely it already matches new ClientSummaryDto structure.
Update GET /admins/clients endpoint to ensure it works with new ClientResponseDto structure.
Verify getAllClients method returns ClientListResponseDto with new ClientResponseDto structure.
Update GET /admins/clients/:id endpoint to accept @Query() query parameter with client include options (includeCapabilities, includeKyc, includePartnership, includeAgent, includePartner).
Import ClientIncludeQueryDto from client module.
Pass query params to getClientById method or directly to clients service findOne method.
Update getClientById in adminsService to accept query params and pass them to client service or handle conditional loading.
Since admins are viewing other clients, capabilities should be empty array even if includeCapabilities=true (only client themselves get real capabilities).
Remove mapToClientDetail method from adminsService since ClientDetailResponseDto no longer exists.
Update getClientById to use the unified client service findOne method with query params.
Add ApiQuery decorators for all client include query parameters (includeCapabilities, includeKyc, includePartnership, includeAgent, includePartner).
Update ApiResponse to use ClientResponseDto instead of ClientDetailResponseDto.

PHASE 8: UPDATE AUTH RESPONSES FOR ADMIN
Check src/auth/auth.service.ts and src/auth/auth.controller.ts for any admin responses in login, register, or token refresh endpoints.
Ensure auth endpoints return unified AdminResponseDto structure with capabilities included by default for authenticated admin user.
Update AuthResponseDto in src/auth/dto/auth-response.dto.ts if it includes admin object to use new AdminResponseDto.
Ensure login and register flows return capabilities for the authenticated admin user.
Admin and client auth responses should be consistent - both include capabilities by default.

PHASE 9: UPDATE SWAGGER DOCUMENTATION
Review all admin endpoint Swagger decorators to ensure they accurately reflect new response structures.
Ensure ApiOperation summaries mention query parameters where applicable.
Add notes about performance implications of includeCapabilities on list endpoints.
Document that GET /admins/me always returns capabilities regardless of query param.
Document that roles are always included in all admin responses.
Document that bank account fields are included in admin responses and users can only update their own.
Remove all documentation references to separate bank account endpoints.

PHASE 10: TESTING AND VALIDATION
Test GET /admins/me without query params - should return base fields with capabilities and bank account info.
Test GET /admins/me?includeCapabilities=true - should return same as above since capabilities always included for /me.
Test PATCH /admins/me with bank account fields - should update bank info successfully.
Test PATCH /admins/me with null bank account fields - should clear bank info.
Test GET /admins/:id without query params - should return base fields with roles but no capabilities.
Test GET /admins/:id?includeCapabilities=true - should return base fields with roles and empty capabilities array.
Test GET /admins (list) without query params - should return list with roles but no capabilities for performance.
Test GET /admins?includeCapabilities=true - should return list with roles and capabilities for each admin.
Test GET /admins/my-clients endpoint - should return clients with new ClientResponseDto structure.
Test GET /admins/clients endpoint - should return clients with new ClientResponseDto structure.
Test GET /admins/clients/:id without query params - should return base client fields only.
Test GET /admins/clients/:id?includeKyc=true&includePartnership=true - should return client with kyc and partnership data.
Verify that trying to access PATCH/GET/DELETE /admins/:id/bank-account returns 404 (endpoints removed).
Verify admin responses always include roles array (never empty or missing).
Verify bank account fields are visible in admin responses when populated.
Check Swagger docs to ensure all query parameters are documented properly.
Verify performance improvement by checking that capabilities service is not called when includeCapabilities not specified.
Test that admins viewing clients via /admins/clients/:id?includeCapabilities=true get empty capabilities array (not the client's actual capabilities).

IMPORTANT NOTE - MODULE DEPENDENCIES:
This admin refactoring has dependencies on other modules:

1. CLIENT MODULE DEPENDENCY (PREREQUISITE):
This admin refactoring depends on the client module refactoring documented in TODO.txt.
The client module must be completed first because:
- ClientDetailResponseDto is being removed and unified into ClientResponseDto
- ClientResponseDto now accepts query parameters for optional fields
- Admin controller endpoints /admins/my-clients, /admins/clients, and /admins/clients/:id use client DTOs
Do not start admin refactoring until client refactoring is complete and tested.

2. AUTH MODULE DEPENDENCY (SUBSEQUENT):
The Auth module will need AdminResponseDto after this refactoring is complete.
Auth endpoints (signup, login, Google OAuth, token refresh) will reuse AdminResponseDto directly.
Auth refactoring is documented in TODO-AUTH-REFACTOR.txt and must be done after this admin refactoring.

REFACTORING ORDER:
1. Complete client refactoring first (TODO.txt)
2. Complete admin refactoring second (this file)
3. Complete auth refactoring last (TODO-AUTH-REFACTOR.txt)

IMPLEMENTATION NOTES:
Do not create any progress tracking in terminal or conversation. Only update this TODO-ADMIN-REFACTOR.txt file.
Remove completed tasks from this file as you finish them.
The database in use is DATABASE_URL="postgresql://postgres:postgres@localhost:5432/realty_db?schema=public" in .env.local.
Do not create any .md files unless explicitly requested.
After all phases complete, run the application with npm run start:dev:local and test the endpoints thoroughly.
DO NOT WRITE Integration or unit test for any reason.
This refactoring must be done after client module refactoring is complete.
