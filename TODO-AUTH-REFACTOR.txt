AUTH MODULE REFACTORING - CONSISTENCY AND SIMPLIFICATION

CONTEXT AND GOALS:
The auth module currently has custom DTOs (ClientInfoDto, AdminInfoDto, UserInfoDto) that duplicate fields already in ClientResponseDto and AdminResponseDto. The goal is to eliminate duplication by reusing the refactored client and admin DTOs directly, group tokens into a nested object, and ensure capabilities are always included in auth responses. This creates a single source of truth for user data structure across the entire application.

PREREQUISITES:
This refactoring MUST be done AFTER both client and admin module refactoring is complete:
1. Client module refactoring (TODO.txt) - provides unified ClientResponseDto
2. Admin module refactoring (TODO-ADMIN-REFACTOR.txt) - provides unified AdminResponseDto
The auth module will import and reuse these DTOs instead of maintaining separate structures.

KEY PRINCIPLES:
1. Reuse ClientResponseDto and AdminResponseDto directly (no custom auth-specific DTOs for user data)
2. Group tokens into nested tokens object for clean separation
3. Capabilities always included in auth responses (users logging in always get their capabilities)
4. One of client or admin is populated, the other is null based on user type
5. No duplication of fields between auth DTOs and module DTOs
6. Single response structure for signup, login, Google OAuth, and token refresh
7. GET /auth/me can be simplified or removed since /clients/me and /admins/me already exist

RESPONSE STRUCTURE:
AuthResponseDto for signup, login, Google OAuth, token refresh:
{
  client: ClientResponseDto | null,
  admin: AdminResponseDto | null,
  tokens: {
    accessToken: string,
    refreshToken: string
  }
}

When client logs in: client property populated with full ClientResponseDto (including capabilities), admin is null.
When admin logs in: admin property populated with full AdminResponseDto (including capabilities), client is null.
Frontend determines user type by checking which property is non-null.

PHASE 1: UPDATE AUTH RESPONSE DTOS
Open src/auth/dto/auth-response.dto.ts and prepare for major restructuring.
Delete ClientInfoDto class entirely (replaced by ClientResponseDto from client module).
Delete AdminInfoDto class entirely (replaced by AdminResponseDto from admin module).
Delete UserInfoDto class entirely (no longer needed with direct DTO reuse).
Create new TokensDto class with accessToken (string) and refreshToken (string) properties. Use ApiProperty decorators.
Update AuthResponseDto to have three properties: client (ClientResponseDto | null), admin (AdminResponseDto | null), tokens (TokensDto). Import ClientResponseDto from clients module and AdminResponseDto from admins module.
Add ApiPropertyOptional decorators for client and admin fields since one will always be null.
Update RefreshTokenResponseDto to match same structure as AuthResponseDto (client, admin, tokens) for consistency.
Alternatively, consider if RefreshTokenResponseDto should only return tokens without user data for performance. Decide based on frontend needs.
Create GetMeResponseDto with just client or admin property and capabilities, or consider deprecating GET /auth/me entirely since /clients/me and /admins/me already exist.

PHASE 2: UPDATE AUTH SERVICE SIGNUP METHODS
Open src/auth/auth.service.ts and locate signUp method for client signup.
After creating user and client in transaction, fetch the complete client data using ClientsService.findByUserId.
This ensures consistent structure and includes capabilities automatically.
Remove manual mapping of client data - delegate to ClientsService which handles the refactored ClientResponseDto.
Generate tokens (accessToken and refreshToken) as before.
Return AuthResponseDto structure: { client: clientData, admin: null, tokens: { accessToken, refreshToken } }.
Locate adminSignUp method for admin signup.
After creating user and admin in transaction, fetch the complete admin data using AdminsService.findByUserId.
This ensures consistent structure and includes capabilities automatically.
Remove manual mapping of admin data - delegate to AdminsService which handles the refactored AdminResponseDto.
Generate tokens as before.
Return AuthResponseDto structure: { client: null, admin: adminData, tokens: { accessToken, refreshToken } }.

PHASE 3: UPDATE AUTH SERVICE LOGIN METHOD
Open src/auth/auth.service.ts and locate login method.
Method receives user object from LocalAuthGuard after validation.
Check user type by looking for user.client or user.admin relationship.
If client: fetch complete client data using ClientsService.findByUserId with capabilities included.
If admin: fetch complete admin data using AdminsService.findByUserId with capabilities included.
Generate tokens (accessToken and refreshToken).
Return AuthResponseDto structure with appropriate client or admin populated, other as null, and tokens nested.
Remove any manual field mapping - rely entirely on ClientsService and AdminsService for consistent structure.

PHASE 4: UPDATE AUTH SERVICE GOOGLE LOGIN METHOD
Open src/auth/auth.service.ts and locate googleLogin method.
This method handles both Google OAuth for clients and admins.
After creating or finding user via Google OAuth, determine user type.
If client: fetch complete client data using ClientsService.findByUserId.
If admin: fetch complete admin data using AdminsService.findByUserId.
Generate tokens.
Return AuthResponseDto structure with client or admin populated and tokens nested.
Ensure Google OAuth callback handlers in controller (googleAuthCallback, googleAdminAuthCallback) work with new structure.
Update redirect URLs to pass tokens correctly if needed.

PHASE 5: UPDATE AUTH SERVICE REFRESH TOKEN METHOD
Open src/auth/auth.service.ts and locate refreshToken method.
After validating refresh token and extracting user info, determine user type.
If client: fetch complete client data using ClientsService.findByUserId.
If admin: fetch complete admin data using AdminsService.findByUserId.
Generate new tokens (accessToken and refreshToken).
Return RefreshTokenResponseDto structure with client or admin and new tokens.
Consider if refresh endpoint should return full user data or just tokens for performance - decide based on frontend needs.
If only tokens needed, create a lighter RefreshTokenResponseDto with just tokens object.

PHASE 6: UPDATE AUTH SERVICE GET ME METHOD
Open src/auth/auth.service.ts and locate getMe method.
This endpoint returns current authenticated user profile.
Consider deprecating this endpoint entirely since /clients/me and /admins/me already exist with same functionality.
If keeping it, determine user type from userId.
Fetch data using ClientsService.findByUserId or AdminsService.findByUserId.
Return GetMeResponseDto with client or admin property and capabilities.
Alternatively, recommend frontend use /clients/me or /admins/me directly and remove GET /auth/me endpoint.

PHASE 7: UPDATE AUTH CONTROLLER
Open src/auth/auth.controller.ts and update all endpoint decorators.
Update POST /auth/signup ApiResponse decorator to use new AuthResponseDto structure.
Update POST /auth/admin/signup ApiResponse decorator to use new AuthResponseDto structure.
Update POST /auth/login ApiResponse decorator to use new AuthResponseDto structure.
Update GET /auth/google/callback to work with new structure (tokens nested in response).
Update GET /auth/google/admin/callback to work with new structure (tokens nested in response).
Update redirect URLs in Google callbacks to extract tokens from nested structure: result.tokens.accessToken and result.tokens.refreshToken.
Update POST /auth/refresh ApiResponse decorator to use new RefreshTokenResponseDto structure.
If keeping GET /auth/me, update ApiResponse decorator to use new GetMeResponseDto structure.
If deprecating GET /auth/me, add deprecation notice in Swagger or remove endpoint entirely.

PHASE 8: INJECT CLIENT AND ADMIN SERVICES
Open src/auth/auth.module.ts and ensure ClientsModule and AdminsModule are imported.
Add ClientsService and AdminsService to AuthModule providers or imports if needed.
In AuthService constructor, inject ClientsService and AdminsService.
Update constructor in src/auth/auth.service.ts: add private clientsService: ClientsService and private adminsService: AdminsService.
Ensure proper imports at top of file.
This allows auth service to delegate fetching user data to the respective services for consistency.

PHASE 9: HANDLE CAPABILITIES IN AUTH RESPONSES
For all auth responses (signup, login, Google OAuth, refresh), capabilities must be included.
ClientsService.findByUserId for /me endpoint always includes capabilities - ensure this is used for auth.
AdminsService.findByUserId for /me endpoint always includes capabilities - ensure this is used for auth.
Do NOT use ClientsService.findOne or AdminsService.findOne which require query params for capabilities.
Always use the findByUserId methods which are specifically for authenticated user requesting own profile.
This ensures capabilities are always present in auth responses without needing query parameters.
Verify that capabilities are never empty in auth responses during testing.

PHASE 10: CLEAN UP UNUSED CODE
After all auth methods updated, review src/auth/auth.service.ts for unused helper methods.
Remove any manual mapping functions that are no longer used (replaced by service delegation).
Remove any duplicate field extraction logic.
Ensure all auth endpoints delegate to ClientsService or AdminsService for user data.
Review src/auth/dto/auth-response.dto.ts and remove any unused DTOs.
Check if GetMeResponseDto is still needed or if GET /auth/me should be removed.
Clean up imports in auth service and controller.

PHASE 11: UPDATE SWAGGER DOCUMENTATION
Review all auth endpoint Swagger decorators for accurate documentation.
Update examples in AuthResponseDto to show nested tokens structure.
Update examples to show either client or admin populated, not both.
Document that capabilities are always included in auth responses.
Add notes about which endpoints populate client vs admin.
If GET /auth/me is deprecated, mark it as deprecated in Swagger or remove documentation.
Ensure RefreshTokenResponseDto examples are consistent with AuthResponseDto structure.

PHASE 12: TESTING AND VALIDATION
Test POST /auth/signup (client) - should return client object with capabilities, admin null, tokens nested.
Test POST /auth/admin/signup - should return admin object with capabilities, client null, tokens nested.
Test POST /auth/login with client credentials - should return client object with capabilities and tokens.
Test POST /auth/login with admin credentials - should return admin object with capabilities and tokens.
Test GET /auth/google/callback - should redirect with tokens and return client object when accessed.
Test GET /auth/google/admin/callback - should redirect with tokens and return admin object when accessed.
Test POST /auth/refresh with valid refresh token - should return new tokens and user object with capabilities.
Test GET /auth/me if kept - should return current user (client or admin) with capabilities.
Verify capabilities are never empty in any auth response.
Verify tokens are always nested in tokens object, never at top level.
Verify exactly one of client or admin is populated, never both, never both null.
Check Swagger docs to ensure all examples and schemas are correct.
Test that frontend can determine user type by checking client !== null vs admin !== null.
Verify no field duplication between AuthResponseDto and ClientResponseDto/AdminResponseDto.
Verify auth responses match /clients/me and /admins/me response structures exactly.

IMPORTANT NOTE - MODULE DEPENDENCIES:
This auth refactoring depends on both client and admin module refactoring being completed:
1. Client module (TODO.txt) must be done first - provides ClientResponseDto with capabilities
2. Admin module (TODO-ADMIN-REFACTOR.txt) must be done second - provides AdminResponseDto with capabilities
3. Auth module (this file) must be done last - imports and reuses both DTOs

The auth module eliminates duplication by delegating to ClientsService and AdminsService instead of maintaining separate DTOs.
Do not start auth refactoring until both client and admin refactoring are complete and tested.

IMPLEMENTATION NOTES:
Do not create any progress tracking in terminal or conversation. Only update this TODO-AUTH-REFACTOR.txt file.
Remove completed tasks from this file as you finish them.
The database in use is DATABASE_URL="postgresql://postgres:postgres@localhost:5432/realty_db?schema=public" in .env.local.
Do not create any .md files unless explicitly requested.
After all phases complete, run the application with npm run start:dev:local and test the endpoints thoroughly.
DO NOT WRITE Integration or unit test for any reason.
This refactoring must be done after both client and admin module refactoring are complete.
Consider whether GET /auth/me should be deprecated since /clients/me and /admins/me provide the same functionality.
